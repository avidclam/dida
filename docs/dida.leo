<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="avidclam.20191107104201.2"><vh>@settings</vh>
<v t="avidclam.20191107232933.1"><vh>@string medium-font-size = 9pt</vh></v>
<v t="avidclam.20191107232835.1"><vh>@string small-font-size = 8pt</vh></v>
<v t="avidclam.20191107232544.1"><vh>@string font-size = 9pt </vh></v>
<v t="avidclam.20191107104237.1"><vh>@bool rst3_call_docutils = False</vh></v>
<v t="avidclam.20191107111310.1"><vh>@string rst3_write_intermediate_extension = .rst</vh></v>
</v>
<v t="avidclam.20191107150325.1"><vh>Фрагменты</vh>
<v t="avidclam.20191107160728.1"><vh>Создать проект на GitHub</vh></v>
<v t="avidclam.20191107162101.1"><vh>Настроить .gitignore</vh></v>
<v t="avidclam.20191107150449.1"><vh>Создать среду python</vh></v>
<v t="avidclam.20191107154943.1"><vh>conf.py</vh></v>
</v>
<v t="avidclam.20191107122350.1"><vh>dida</vh>
<v t="avidclam.20191107113327.1"><vh>@rst index</vh>
<v t="avidclam.20191111122556.1"><vh>@rst-no-head intro</vh></v>
<v t="avidclam.20191111122650.1"><vh>@rst-no-head toctree</vh></v>
<v t="avidclam.20191111122732.1"><vh>@rst-no-head &lt;index-entries&gt;</vh></v>
<v t="avidclam.20191111122801.1"><vh>@rst-no-head footer</vh></v>
</v>
<v t="avidclam.20191107105031.1"><vh>@rst this-site</vh>
<v t="avidclam.20191107135638.1"><vh>Требуется</vh></v>
<v t="avidclam.20191107105156.1"><vh>Технологии</vh></v>
<v t="avidclam.20191107145156.1"><vh>Действия</vh>
<v t="avidclam.20191107160728.1"></v>
<v t="avidclam.20191107162101.1"></v>
<v t="avidclam.20191107150449.1"></v>
<v t="avidclam.20191107163123.1"><vh>Настроить sphinx</vh></v>
<v t="avidclam.20191107233624.1"><vh>Выбрать редактор</vh></v>
<v t="avidclam.20191108133333.1"><vh>Настроить livereload</vh></v>
<v t="avidclam.20191108140816.1"><vh>Настроить Read the Docs</vh></v>
</v>
<v t="avidclam.20191107160103.1"><vh>Файлы</vh>
<v t="avidclam.20191107171459.1"><vh>conf.py</vh></v>
<v t="avidclam.20191108140008.1"><vh>livereload</vh></v>
</v>
</v>
<v t="avidclam.20191108073206.1"><vh>@rst leo</vh></v>
<v t="avidclam.20191113102041.1"><vh>@rst python</vh>
<v t="avidclam.20191113102147.1"><vh>pytest</vh>
<v t="avidclam.20191113102227.1"><vh>Fixtures</vh></v>
<v t="avidclam.20191113104456.1"><vh>Проверка исключений</vh></v>
<v t="avidclam.20191113212016.1"><vh>Перехват stdout/stderr</vh></v>
</v>
</v>
<v t="avidclam.20200109092449.1"><vh>@rst redhat</vh>
<v t="avidclam.20200109092637.1"><vh>Установка</vh>
<v t="avidclam.20200109092653.1"><vh>Failed to set MokListRT</vh></v>
<v t="avidclam.20200109102910.1"><vh>Параметры</vh></v>
<v t="avidclam.20200109125808.1"><vh>Регистрация</vh></v>
<v t="avidclam.20200109123826.1"><vh>Обновление промежуточное</vh></v>
<v t="avidclam.20200109165702.1"><vh>Leapp</vh></v>
<v t="avidclam.20200110124654.1"><vh>Починка</vh></v>
<v t="avidclam.20200110125519.1"><vh>Проверка</vh></v>
</v>
<v t="avidclam.20200110155153.1"><vh>Курс администратора</vh>
<v t="avidclam.20200110163051.1"><vh>Отличия RHEL8 от RHEL7</vh></v>
<v t="avidclam.20200110165512.1"><vh>Замечания по установке</vh></v>
<v t="avidclam.20200110170245.1"><vh>Задания</vh>
<v t="avidclam.20200110170258.1"><vh>Переустановить забытый пароль</vh></v>
<v t="avidclam.20200110172233.1"><vh>Включить SELinux</vh></v>
<v t="avidclam.20200113111559.1"><vh>Перейти в графический режим</vh></v>
<v t="avidclam.20200113125401.1"><vh>Настроить имя хоста и сеть</vh></v>
<v t="avidclam.20200113161640.1"><vh>Замечания про модули и репозитории</vh></v>
<v t="avidclam.20200113172040.1"><vh>Запускать задания по расписанию</vh></v>
<v t="avidclam.20200114163212.1"><vh>Замечания про grub2</vh></v>
<v t="avidclam.20200114115231.1"><vh>Разное</vh></v>
</v>
</v>
</v>
<v t="avidclam.20200116172244.1"><vh>Kerberos-авторизация</vh>
<v t="avidclam.20200117131847.1"><vh>Защищаем SSHD</vh></v>
<v t="avidclam.20200117162449.1"><vh>Настраиваем KDC</vh></v>
<v t="avidclam.20200117170942.1"><vh>Настраиваем server</vh></v>
<v t="avidclam.20200118194844.1"><vh>Доменный вход</vh></v>
</v>
<v t="avidclam.20191112105836.1"><vh>@rst linux</vh>
<v t="avidclam.20200115113137.1"><vh>Магия чисел</vh>
<v t="avidclam.20191227103823.1"><vh>Виртуальные машины</vh></v>
<v t="avidclam.20200115113333.1"><vh>Нестандарт</vh></v>
</v>
<v t="avidclam.20191226145846.1"><vh>Что происходит?</vh>
<v t="avidclam.20200116163831.1"><vh>Что это за устройство?</vh></v>
<v t="avidclam.20191226145905.1"><vh>Watch</vh></v>
</v>
<v t="avidclam.20191112105856.1"><vh>Bash</vh>
<v t="avidclam.20191112105906.1"><vh>Работа с фоновыми процессами</vh></v>
</v>
</v>
<v t="avidclam.20191108144631.1"><vh>@rst useful-url</vh>
<v t="avidclam.20191108144810.1"><vh>reStructuredText</vh></v>
</v>
<v t="avidclam.20191111073339.1"><vh>@rst autosphinx</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="avidclam.20191107104201.2"></t>
<t tx="avidclam.20191107104237.1"></t>
<t tx="avidclam.20191107105031.1">Этот сайт
=========

</t>
<t tx="avidclam.20191107105156.1">- Python + Sphinx + sphinx-rtd-theme
- Редактор leo
- livereload
- git, GitHub, Read the Docs
</t>
<t tx="avidclam.20191107111310.1"></t>
<t tx="avidclam.20191107113327.1"></t>
<t tx="avidclam.20191107122350.1">@language python
"""
Auto-fills index entries into index.rst file 
by rewriting '@rst-no-head &lt;index-entries&gt;' node.
Finally, executes 'rst3' command.
Use Ctrl+B to run the script.
"""

target_ending = '&lt;index-entries&gt;'
idx_node = p.firstChild()  # assumes index node is the first one
idx_subnodes = idx_node.children()
idx_entries_node = None
for subnode in idx_subnodes:
    if subnode.h.endswith(target_ending):
        idx_entries_node = subnode
        break
if idx_entries_node is not None:
    content_nodes = idx_node.following_siblings()
    rst_names = [nd.h[5:] for nd in content_nodes if nd.h.startswith('@rst ')]
    idx_entries_node.b = '   ' + '\n   '.join(rst_names) + '\n'

c.executeMinibufferCommand('rst3')
</t>
<t tx="avidclam.20191107135638.1">- создавать заметки в текстовом редакторе
- генерировать на их основе статический сайт с нужной структурой, синтаксической разметкой кода и т.п.
- размещать созданный сайт на своем домене, не связываясь с хостинг-провайдерами</t>
<t tx="avidclam.20191107145156.1"></t>
<t tx="avidclam.20191107150325.1"></t>
<t tx="avidclam.20191107150449.1">::

    alias venv='source venv/bin/activate'
    python3 -m venv venv
    venv
    pip install -U pip</t>
<t tx="avidclam.20191107154943.1">.. literalinclude :: conf.py
   :language: python</t>
<t tx="avidclam.20191107160103.1"></t>
<t tx="avidclam.20191107160728.1">Если не настроен локальный git, то выполнить::

    git config --global user.name "Your Name"
    git config --global user.email "your.email@your-place.com"
    git config --global alias.hist "log --oneline --graph --decorate --all"

На GitHub нажать Create a new repository:

- выбрать Owner (себя или одну из созданных ранее Организаций), 
- задать Repository name и Description, 
- отметить "Initialize this repository with a README", 
- Add .gitignore: Python,
- задать лицензию, например, MIT

Далее на компе::

    cd ~/work
    git clone https://github.com/avidclam/dida.git  # см. repo url
    cd dida  # см. имя проекта
    git mv README.md README.rst  # если хочется
    vi README.rst  # ... и сделать описание в формате RST
    git add .
    git commit -m 'Local repo ready'
    git push</t>
<t tx="avidclam.20191107162101.1">В дополнение к .gitignore, который предлагает github, можно добавить::

    /sandbox/
    /log/
    *.orig
</t>
<t tx="avidclam.20191107163123.1">В директории проекта (например, ``~/work/dida``) выполнить::

    pip install sphinx
    pip install sphinx-rtd-theme
    mkdir docs
    cd docs
    sphinx-quickstart

На вопрос "Separate source and build directories (y/n) [n]:" ответить n
(не принципиально, но структура директорий будет немного отличаться).

Получившийся файл ``conf.py`` подправить по образцу, см. `Файлы`_.
</t>
<t tx="avidclam.20191107171459.1">.. code-block:: python

    project = 'Project Name'
    copyright = '2019, Project Author'
    author = 'Project Author'
    release = '0.1.0'
    master_doc = 'index'
    extensions = []
    templates_path = ['_templates']
    language = 'ru'
    exclude_patterns = ['_build']
    html_theme = 'sphinx_rtd_theme'
    html_static_path = ['_static']</t>
<t tx="avidclam.20191107232544.1">**Important**: This should be set by each user.</t>
<t tx="avidclam.20191107232835.1">A small font size used by default in the status area.</t>
<t tx="avidclam.20191107232933.1">A small font size used by default in the check boxes in the Find tab.</t>
<t tx="avidclam.20191107233624.1">Здесь используется :ref:`chapter_leo`, удачный инструмент редактирования документации.
</t>
<t tx="avidclam.20191108073206.1">.. _chapter_leo:

Редактор Leo
============

В проекте используется редактор `Leo Editor &lt;https://leoeditor.com&gt;`_. Это довольно специфическая среда редактирования/программирования, обладающая при всей непривычности несколькими привлекательными для данного проекта особенностями:

- Во-первых, Leo написан на python и инсталлируется привычной командой ``pip install leo``. 
- Во-вторых, вся текстовая часть сайта, с учетом структуры, сохраняется в едином файле (внешние ресурсы --- картинки, pdf-файлы и т.п. --- нужно держать отдельно). 
- В-третьих, единица редактирования --- не файл, а блок текста (outline). Структура контента хорошо видна, удобно редактировать мелкие фрагменты, а потом собирать из них сайт. Набор rst-файлов, готовых для обработки sphinx, генерируется одной командой. 
- И наконец, есть "клоны", т.е. синхронно обновляемые блоки, которые могут использоваться независимо. Изменение одного из клонов приводит к автоматическому обновлению соответствующих фрагментов других страниц сайта.

Для примера ниже приводится сриншот панели Outline на момент редактирования главы "Этот сайт".

.. figure:: _static/screenshots/leo.png
    :align: center

Примечательно следующее:

- под @settings можно переопределять системные параметры, даже такие "глобальные" как размер шрифта
- rst3_call_docutils = False говорит системе, что использется Sphinx а не docutils
- заметки под @rst this-site объединяются в единый файл this-site.rst, причем заголовки заметок становятся заголовками подразделов
- некоторые заметки, такие как "Настроить проект на GitHub" --- это клоны заметок, подготовленных во "Фрагментах"
- генерация rst-файлов происходит по команде ``rst3``, заданной в минибуфере</t>
<t tx="avidclam.20191108133333.1">Команда ``make html`` в директории ``docs`` запускает Sphinx для создания сайта из подготовленных rst-файлов. Пакет `livereload &lt;https://github.com/lepture/python-livereload&gt;`_ автоматически запускает sphinx при каждом изменении исходных файлов и обеспечивает локальный веб-доступ к созданному сайту.

После установки пакета командой ``pip install livereload`` нужно, как описано в Readme livereload, создать исполняемый скрипт (см. ниже), допустим, ``bin/livereload`` и запускать его командой::

    ./bin/livereload &gt; ./log/livereload.log &amp;2&gt;1 &amp;

Обновляемый сайт доступен по адресу http://localhost:5500/index.html

Можно воспользоваться скриптом :ref:`chapter_autosphinx`.
</t>
<t tx="avidclam.20191108140008.1">.. literalinclude :: ../bin/livereload
   :language: python</t>
<t tx="avidclam.20191108140816.1">Использование Read the Docs интуитивно. Основные действия по импорту проекта из GitHub проводятся на странице `списка проектов &lt;https://readthedocs.org/dashboard&gt;`_. Полезные возможности хорошо описаны в `документации &lt;https://docs.readthedocs.io/en/stable/&gt;`_:

- `Размещение на своём домене &lt;https://docs.readthedocs.io/en/stable/custom_domains.html&gt;`_
- `Привязка Google Analytics к сайту &lt;https://docs.readthedocs.io/en/stable/guides/google-analytics.html&gt;`_</t>
<t tx="avidclam.20191108144631.1">Полезные ссылки
===============

Ниже, без особой системы, даны ссылки на полезные ресурсы.</t>
<t tx="avidclam.20191108144810.1">- `Online Sphinx editor &lt;https://livesphinx.herokuapp.com&gt;`_</t>
<t tx="avidclam.20191111073339.1">.. _chapter_autosphinx:

autosphinx --- скрипт для livereload
====================================

Скрипт `livereload &lt;https://github.com/lepture/python-livereload&gt;`_
для запуска Sphinx и пересборки html-документации 
при изменении исходных rst-файлов, был доработан и назван ``autosphinx``.

Его можно запускать из директории проекта, папки docs или еще на один
уровень ниже, например, docs/source.

Ключ ``-l`` перенаправляет вывод в лог-файл log/autosphinx.log

Типичный запуск будет выглядеть примерно так::
    
    autosphinx -p 5501 -w 3 -l&amp;

Код скрипта ниже:

.. literalinclude :: ../bin/autosphinx
   :language: python</t>
<t tx="avidclam.20191111122556.1">.. meta::
   :keywords: linux, python, sphinx, reStructuredText

Записки самоучки
================

Некогда, буквально восприняв ``#learntocode``, я без особого труда прошел отличный вводный курс "`Программирование на Python &lt;https://stepik.org/course/67/promo&gt;`_" и решил, что так победим. Очень скоро однако выяснилось, что для мало-мальски полезного проекта требуются хотя бы базовые навыки в куче смежных технологий. 

Не то чтобы они были неподъемны. Проблема в том, что интуитивность --- не сильная сторона компьютерных технологий, и без постоянного использования полученные знания немедленно выветриваются из головы.

Чтобы не читать снова и снова одни и те же *Getting Started*, я стал записывать для себя (и тут же терять) краткие инструкции, а когда познакомился со Sphinx, решил оформлять новые заметки сразу в виде сайта и держать всё на `GitHub &lt;https://github.com/&gt;`_ и `Read the Docs &lt;https://readthedocs.org/&gt;`_, т.е. под рукой.</t>
<t tx="avidclam.20191111122650.1">.. toctree::
   :maxdepth: 1
   :caption: Содержание:</t>
<t tx="avidclam.20191111122732.1">   this-site
   leo
   python
   redhat
   linux
   useful-url
   autosphinx
</t>
<t tx="avidclam.20191111122801.1">Указатели и поиск
=================

* :ref:`search`

Ключевые слова: Linux, Python, Sphinx, reStructuredText</t>
<t tx="avidclam.20191112105836.1">Linux, разное
=============</t>
<t tx="avidclam.20191112105856.1"></t>
<t tx="avidclam.20191112105906.1">::
    
    autosphinx -l &amp;  # launch background job
    jobs  # list background jobs, add -l for PIDs
    fg %1  # put job #1 into foreground
    # Ctrl+Z: put foreground process on pause
    bg  # continue running process in the background
    kill -HUP %1  # send hangup to the process
    disown %1  # detach job from terminal</t>
<t tx="avidclam.20191113102041.1">Python
======</t>
<t tx="avidclam.20191113102147.1"></t>
<t tx="avidclam.20191113102227.1">К слову об интуитивности ...

Допустим, нужно в тест-функции использовать какие-то данные, 
скажем, ``{'x': 1, 'a': 'one'}``.
Для этого в файле ``tests/conftest.py`` создается fixture:

.. code-block:: python

    data_x_a = {'x': 1, 'a': 'one'}
    
    @pytest.fixture(name='data_x_a')
    def data_x_a_fixture():
        return data_x_a

Теперь данные можно использовать в своих sandbox-скриптах,

.. code-block:: python

    from tests.conftest import data_x_a
    # some code

и тестовая функция может принимать ``data_x_a``:

.. code-block:: python

    def test_data(data_x_a):
        assert 'x' in data_x_a
        assert 'a' in data_x_a

В составе pytest есть и готовые к использованию fixtures, 
такие как `tmp_path &lt;http://doc.pytest.org/en/latest/tmpdir.html&gt;`_
(временная директория) или
`capsys &lt;https://docs.pytest.org/en/latest/reference.html?highlight=capsys#capsys&gt;`_
(перехват вывода в stdout/stderr).
Их не нужно явно импортировать.

</t>
<t tx="avidclam.20191113104456.1">Протестировать на исключения можно с помощью
`pytest.raises &lt;https://docs.pytest.org/en/latest/reference.html#pytest-raises&gt;`_.

.. code-block:: python

    def test_exception(data_x_a):
        with pytest.raises(KeyError, match=r"nonexistent"):
            data_x_a['nonexistent']
</t>
<t tx="avidclam.20191113212016.1">.. code-block:: python

    def test_stdout(capsys):
        msg = 'Go capture stdout'
        print(msg)
        captured = capsys.readouterr()
        assert captured.out == msg + "\n"</t>
<t tx="avidclam.20191226145846.1"></t>
<t tx="avidclam.20191226145905.1">Довольно тривиальная команда, но почему-то все время забывается.
Допустим, нужно, запустив процесс, последить, какие файлы он добавляет в директорию.

Здесь нам поможет::

    watch tree &lt;directory&gt;</t>
<t tx="avidclam.20191227103823.1">Полезна единая система номеров для виртуальных машин.

Например, используется сеть 192.168.68/24, IP-адреса виртуальных машин начинаются с 81, а имя хоста первой виртуалки: ``uno``. 

.. table:: Пример настройки параметров первой виртуальной машины:
   :widths: auto

   =================  ================================  ==========
   Название VM                      uno81               или vm81uno, например
   MAC-адрес                         0A:C0:A8:44:51:01  (т.е. 10:192:168:68:81:1)
   IP-адрес                            192.168.68.81
   Порт VNC-консоли             5981
   =================  ================================  ==========

Соображения по MAC-адресу:
    
    Чтобы MAC-адрес распознался как Locally Administered MAC Аddress, он должен начинаться с x2, x6, xA или xE. Далее октеты могут быть любыми. Удобно, чтобы они соответствовали IP-адресу. В последнем октете ставится единица, если сеть строится по правилу "один интерфейс --- один адрес", либо используются разные цифры для более хитрых настроек.
</t>
<t tx="avidclam.20200109092449.1">Red Hat Linux
=============</t>
<t tx="avidclam.20200109092637.1"></t>
<t tx="avidclam.20200109092653.1">Знакомство с Red Hat Linux начинается с сообщения::
    
    Failed to set MokListRT: Invalid Parameter
    Something has gone seriously wrong: import_mok_state() failed:
    Invalid Parameter

Вроде бы виноваты пакеты ``shim-x64`` и ``mokutil``
и поэтому предлагается их не обновлять во избежание проблем::

   echo "exclude=shim-x64,mokutil" &gt;&gt; /etc/yum.conf

Прекрасное решение для работающей системы, которой пока нет. Ставим 7.6.
</t>
<t tx="avidclam.20200109102910.1">Устанавливаем с учетом Installation Guide, в частности, Recommended Partitioning Scheme,
а также по мотивам https://habr.com/ru/post/469097/.

Выделено два диска по 24Gb, один из них подключен на этапе установки, другой подключим после.

Разбивка диска::
    
    swap	2Gb (см. ниже)
    /boot	1Gb (не lvm, ext4)
    /boot/efi   200M (не lvm, vfat)
    /		10Gb (lvm, ext4)
    /var	4Gb (lvm, ext4)
    /home   1Gb (lvm, ext4)
    остальное место остается в запасе

Место под swap выделено из соображений стандартности и как запас.
Есть мнение, что в виртуалках swap не нужен, а, например, руководство по Elasticsearch явно рекомендует не использовать swap.
Установка автоматически создает swap, но его можно отключить, для этого закомментировать соответствующую строчку в /etc/fstab, а в консоли набрать::
    
    lsblk
    swapoff /dev/vda3
    free -h

Можно отключить еще и на уровне ядра::
    
    echo "vm.swappiness=0" &gt;&gt; /etc/sysctl.conf
    reboot

Остальное стандартно: часовой пояс Московский, сеть настраивается, пользователь не создается, 
после каждого большого этапа делается shapshot виртуального диска.
</t>
<t tx="avidclam.20200109123826.1">После регистрации и оформления подписки можно обновиться.
Сначала обновляется текущая система в рамках 7.6, с учетом "исключенных" пакетов::
    
    yum clean all
    echo "exclude=shim-x64,mokutil" &gt;&gt; /etc/yum.conf
    yum --releasever=7.6 update

Подробности обновления в рамках минорной версии см. https://access.redhat.com/solutions/238533

Далее нужно обновиться до 7.6 EUS::
    
    subscription-manager repos --disable rhel-7-server-rpms --enable rhel-7-server-eus-rpms
    subscription-manager repos --enable rhel-7-server-extras-rpms
    subscription-manager repos --disable rhel-7-server-optional-rpms --enable rhel-7-server-eus-optional-rpms
    subscription-manager repos --disable rhel-7-server-supplementary-rpms --enable rhel-7-server-eus-supplementary-rpms
    subscription-manager release --set 7.6
    yum update
    reboot

Делаем копию копию /boot/efi/EFI в директорию /boot/efi/EFI76, пригодится.
</t>
<t tx="avidclam.20200109125808.1">RHEL --- продукт коммерческий и хотя он доступен для разработчиков, использование требует управления подписками.

Сначала нужно зарегистрировать систему::
    
    subscription-manager register

В качестве username --- короткое имя пользователя, **не email**.

Затем нужно присоединить (attach) подписку к зарегистрированной системе::
    
    subscription manager attach

Неплохо зайти на Customer Portal посмотреть, как зарегистрировалась система: https://access.redhat.com/management/systems
</t>
<t tx="avidclam.20200109165702.1">Обновление на версию 8 начинается с утилиты Leapp. Сначала::
    
    yum install leapp
    
Далее нужно скачать файл ``leapp-data6.tar.gz`` из статьи 
https://access.redhat.com/articles/3664871 и распаковать его в нужное место::
    
    tar -xzf leapp-data6.tar.gz -C /etc/leapp/files &amp;&amp; rm leapp-data6.tar.gz

Потом запустить этап оценки обновляемости::
    
    leapp preupgrade

почитать отчет /var/log/leapp/leapp-report.txt и настроить согласно рекомендациям как минимум то, 
что отмечено как inhibitor. В данном случае надо установить "PermitRootLogin yes" в sshd_config,
что пока не требуется (sshd еще не настраивали), но позволяет пройти дальше с обновлением.

Notes:
    Причина рекомендации --- изменилось поведение по умолчанию в RHEL8. 
    Если параметр PermitRootLogin явно не установлен, вход с паролем запрещается.


Наконец, идет непосредственно этап обновления::
    
    leapp upgrade

После ряда обновлений leapp говорит, что необходимо перегрузиться для продолжения.
После перезагрузки предлагается стартовать RHEL8 initramfs, который все обновит и снова перезагрузится.
После второй перезагрузки нас ждет приз: "Failed to set MokListRT".
</t>
<t tx="avidclam.20200110124654.1">Не очень понятно, как чинить новый EFI, поэтому просто заменим shim на старый.
Для этого подключим установочный диск 7.6 и при загрузке выберем Troubleshooting -&gt; Rescue. Далее

::
    
    cd /mnt/sysimage/boot/efi
    cp -a EFI EFI81
    cp EFI76/BOOT/BOOT* EFI/BOOT
    cp EFI76/redhat/shim* EFI/redhat
    shutdown now

Отключаем установочный диск, перегружаемся, и все вроде работает.
</t>
<t tx="avidclam.20200110125519.1">Надо убедиться, что у нас действительно версия 8.1::
    
    cat /etc/redhat-release

И соответствующее ядро::
    
    uname -r
    
И подписка соответствует::
    
    subscription-manager list --installed
    
Отменяем привязку к версии::
    
    subscription-manager release --unset

И включаем SELinux::
    
    setenforce 1</t>
<t tx="avidclam.20200110155153.1">Ниже заметки слушателя курса RHCSA на Udemy https://www.udemy.com/course/rhcsa-practice-exam-questions-ex200-redhat-release-7/.
На всякий случай, страница экзамена: https://www.redhat.com/en/services/training/ex200-red-hat-certified-system-administrator-rhcsa-exam.

Заметки касаются только части вопросов, имеющих отношение к развертыванию одиночной системы RHEL/CentOS в Интернете.
Не отражены разделы курса, посвященные таким "корпоративным" темам, как авторизация пользователей по LDAP, локальные репозитории и др.
</t>
<t tx="avidclam.20200110163051.1">* От единого репозитория к двум: BaseOS и AppStream. Добавилась концепция "модулей" (логически связанный набор пакетов).
* YUM обновлен до версии 4 (DNF), поддерживающей модули.
* Устарел ntp daemon, поддерживается только chronyd для синхронизации времени.
* Средство настройки сети --- Network Manager. Скрипты ipup/ipdown зависят от nmcli.
* Добавлена поддержка Stratis как среддства storage management.
* Вместо authconfig --- authselect.</t>
<t tx="avidclam.20200110165512.1">При установке на VM нужно корректно подобрать виртуальное "железо".

* HDD: (IDE or SATA disk type, not SCSI)

Если хочется иметь "старые" названия сетевых интерфейсов (eth0, eth1), то можно до первой загрузки с DVD добавить ``net.ifnames=0`` [1]_ в параметры ядра соответствующей записи grub.

Тип установки можно выбрать любой, но не "Server with GUI".

.. [1] См. https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/networking_guide/sec-understanding_the_device_renaming_procedure
</t>
<t tx="avidclam.20200110170245.1"></t>
<t tx="avidclam.20200110170258.1">В меню GRUB надо нажать "e" (edit) и в строчку ядра (начинается с linux) дописать ``rd.break`` в конце, после чего нажать Ctrl+x для продолжения загрузки.
В режиме rescue перемонтировать корневую директорию для чтения-записи, переустановить пароль и указать SELinux на необходимость переразметки::
    
    mount -o remount,rw /sysroot
    chroot /sysroot
    passwd
    touch /.autorelabel
    exit
    mount -o remount,ro /sysroot
    reboot
</t>
<t tx="avidclam.20200110172233.1">Текущий режим можно узнать с помощью getenforce или sestatus, а установить --- в /etc/selinux/config::
    
    SELINUX=enforcing

Активируется при перезагрузке.</t>
<t tx="avidclam.20200113111559.1">То, что когда-то настраивалось через runlevel (от 0 до 5) в /etc/inittab, в systemd настраивается через "target":
        
* poweroff.target
* rescue.target
* multi-user.target ("текстовой режим", runlevel 3)
* graphical.target ("графический режим", runlevel 5)
* reboot.target

Текущий target можно посмотреть командой ``systemctl get-default``.

Где есть get default, должен быть set default, и он есть::
    
    systemctl isolate graphical.target
    systemctl set-default graphical.target

Чтобы было куда переключаться, нужно установить нужные пакеты, например, так::
    
    dnf group list
    dnf groupinstall "Server with GUI"

Для информации, юниты systemd находятся в директории /usr/lib/systemd/system/ . 
Системные настройки, касающиеся юнитов --- в /etc/systemd/system/ .
Например, default.target --- это ссылка на /usr/lib/systemd/....

</t>
<t tx="avidclam.20200113125401.1">Имя хоста настраивается, например, так::
    
    hostnamectl set-hostname system.example.com

Сеть настраивается с помощью Network Manager.
Команда ``nmcli`` без параметров выдает информацию о текущих настройках.
Команда ``ip addr`` показывает интерфейсы и соответствующие IP-адреса, ``ip route show`` --- настройку маршрутизации.

Следующие интуитивные команды настраивают и поднимают статическое IP-соединение::
    
    nmcli connection add con-name system type ethernet ifname eth0 ipv4.address 192.168.122.10/24 ipv4.gateway 192.168.122.1 ipv4.dns 192.168.122.254 ipv4.method manual 
    nmcli connection up system

Рестартовать Network Manager можно стандартно::
    
    systemctl restart NetworkManager

Посмотреть текущие установки можно в директории

::
    
    /etc/sysconfig/network-scripts
</t>
<t tx="avidclam.20200113161640.1">Некоторые полезные сведения о репозиториях, пакетах и управлении ими.

* Вместо yum -\&gt; dnf
* Модульная структура пакетов

Модули и стримы можно просмотреть и установить независимо.

::
    
    dnf module list
    dnf module info python36
    dnf module info --profile python36:3.6
    dnf install @python36

* Как уже говорилось, в RHEL8 два репозитория --- BaseOS и AppStream.
* Их можно найти, например, на ISO-диске RHEL8 в директориях с соответствующими именами и скопировать локально.

После копирования создадим файл /etc/yum.repos.d/system.repo со следующим содержимым::
    
    [BaseOS]
    name = BaseOS
    baseurl = file:///root/BaseOS
    gpgcheck = 0
    enabled = 1
    [AppStream]
    name = AppStream
    baseurl = file:///root/AppStream
    gpgcheck = 0
    enabled = 1

Далее::
    
    dnf clean all
    
Проверка::
    
    dnf repolist
    dnf groups list

    </t>
<t tx="avidclam.20200113172040.1">Создадим пользователя::
    
    useradd -c "Regular User" -d /home/regular -m --user-group -u 5010 regular
    passwd regular
    su - regular

Рекомендация по выбору ID для RHEL8: *The recommended practice is to assign IDs starting at 5,000*, так что UID=5010 вполне соответствует.

Создадим скрипт, например, такой::
    
    su - regular
    mkdir bin
    mkdir log
    echo "#!/bin/bash" &gt; bin/cronjob.sh
    echo "date &gt;&gt; /home/regular/log/cron.log" &gt;&gt; bin/cronjob.sh
    chmod u+x bin/cronjob.sh
    exit

Настроим cron

::

    crontab -u regular -e
    # в редакторе добавим строчку
    */3 * * * * /home/regular/bin/cronjob.sh

Скрипт будет исполняться каждые 3 минуты.

Чтобы скрипт выполнялся, например, в 12:15 каждый понедельник, нужно было прописать строчку::
    
    15 12 * * 1 /home/regular/bin/cronjob.sh

Кстати, вполне приличное описание crontab есть в Википедии https://ru.wikipedia.org/wiki/Cron

::
    
    * * * * * выполняемая команда
    - - - - -
    | | | | |
    | | | | ----- день недели (0—7) (воскресенье = 0 или 7)
    | | | ------- месяц (1—12)
    | | --------- день (1—31)
    | ----------- час (0—23)
    ------------- минута (0—59)
    
Пользователю можно дать права самостоятельно настраивать свои задания. 
Для этого требуется внести пользователя в файл /etc/cron.allow

::
    
    echo "regular" &gt;&gt; /etc/cron.allow
    

Удаляются задания с помощью ``crontab -r``.

Для разового запуска задания по расписанию используем atd. 
Он не установлен по умолчанию. Поэтому::
    
    dnf install at
    systemctl start atd
    systemctl status atd

Для конфигурирования задания нужно войти в командную оболочку ``at``
с указанием необходимомо времени выполнения задания. Например::
    
    at 4 PM + 2 days # или
    at now + 30 min

В оболочке нужно набрать команду и нажать Ctrl+D для выхода.

Проверить, что есть задание по расписанию, можно командой ``atq``.
</t>
<t tx="avidclam.20200114115231.1">Посмотреть источники синхронизации времени chronyd можно командой::
    
    chronyc sources -v

</t>
<t tx="avidclam.20200114163212.1">Много где, например, здесь --- https://wiki.centos.org/HowTos/Grub2 --- написано, что если мы хотим изменить параметры ядра при запуске (kernelopts), то нужно отредактировать файл ``/etc/default/grub`` и запустить

::
    
    grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg

Оказывается, так может не работать, и вот почему. 

Параметры, заданные в GRUB_CMDLINE_LINUX файла /etc/default/grub, переносятся скриптом grub2-mkconfig в переменную окружения kernelopts. См.::
    
    grub2-editenv - list

Параметры старта каждого пункта меню GRUB, 
в соответствии с https://systemd.io/BOOT_LOADER_SPECIFICATION/,
описываются в .conf файлах, расположенных в директории ``/boot/loader/entries/``.
Обычно в них присутствует строчка

::
    
    options $kernelopts $tuned_params

Однако ``options`` могут задаваться и непосредственно в conf-файле. В таком случае заданные где-то еще kernelopts никак не используются, 
и для изменения параметров запуска ядра нужно редактировать 
непосредственно conf-файл в директории ``/boot/loader/entries``.
</t>
<t tx="avidclam.20200115113137.1"></t>
<t tx="avidclam.20200115113333.1">Время от времени появляется желание использовать недефолтные UID для пользователей и нестандартные номера портов сетевых служб (например, из соображений безопасности). 
По прошествии времени вся нумерация, естественно, забывается, и вспомнить, на какой порт был в итоге повешен sshd, бывает затруднительно.

Простой выход из положения --- считать UID административного пользователя (не root) магическим числом, базой нумерации. 

Пример: на группе машин административный пользователь ``resurepus`` имеет UID=23400.
Тогда если забылась вся нумерация, достаточно команды ``id``, чтобы вспомнить, что sshd располагается на порту 23422, служебный веб-сервер --- на 23480, и т.п.
</t>
<t tx="avidclam.20200116163831.1">Хотим, например, узнать параметры аппаратного сетевого интерфейса eth0. А вот::
    
    for f in $(find /sys/devices -name eth0); do udevadm info $f; done
</t>
<t tx="avidclam.20200116172244.1">Итак, есть машины ``kdc``, ``server`` и ``ws``. Домен ``mynet``, dns имеется. 

Требуется настроить так, чтобы с рабочей станции ws можно было через ssh войти на server, авторизовавшись через Kerberos, установленный на kdc. Чтобы приблизить задачу к реальности, добавим недефолтные настройки sshd.
</t>
<t tx="avidclam.20200117131847.1">Сервер KDC должен быть хорошо защищен. 
Для этого ставится минимальный Centos, sshd вешается на нестандартный порт и настраивается так, чтобы войти можно было только при наличии и ключа, и пароля.
Оставим вход под root (решение, несомненно, спорное) -- по умолчанию он разрешен, только добавим требование публичного ключа.

Нестандартный порт недостаточно прописать в /etc/ssh/sshd_config в строчке Port. 
Нужно настроить firewall.

Для этого создадим и добавим в конфигурацию новый файл описания сервиса ssh для firewalld::
    
    cd /usr/lib/firewalld/services
    cp ssh.xml ssh-custom.xml
    vi ssh-custom.xml  # Change port
    firewall-cmd --permanent --remove-service='ssh'
    firewall-cmd --permanent --add-service='ssh-custom'

Не забудем про selinux::
    
    dnf provides /usr/sbin/semanage
    dnf install policycoreutils-python-utils
    semanage port -a -t ssh_port_t -p tcp 23422 

Заодно посмотрим, что пропускает firewalld, и уберем лишнее::
    
    firewall-cmd --list-services
    firewall-cmd --permanent --remove-service='cockpit'
    firewall-cmd --permanent --remove-service='dhcpv6-client'

Перезапустим сервисы, проверим::
    
    systemctl restart sshd
    lsof -i  # if lsof is installed
    firewall-cmd --reload
    firewall-cmd --list-services  # shoud be ssh-custom only

и c рабочей станции::
    
    ssh -p 23422 root@kdc

Логин по паролю должен пройти без проблем.
Начнем разбираться с сертификатами. На рабочей станции::
    
    ssh-keygen -t rsa
    ssh-copy-id -i ~/.ssh/id_rsa.pub -p 23422 root@kdc
    ssh -p 23422 root@kdc
    restorecon -Rv ~/.ssh   # on kdc
    systemctl restart sshd

Теперь можно войти без пароля, если есть ключ, и с паролем, если ключа нет.
Это не совсем то, что мы хотели. Нам надо было, чтобы пароль для входа был обязателен.
Для этого необходимо в файл /etc/ssh/sshd_config добавить строчку::
    
    AuthenticationMethods "publickey,password"

Желательно вместо изначального файла /etc/ssh/sshd_config с комментариями и т.п. поставить файл с ясными и компактными настройками, например, такой::

    Protocol 2
    Port 23422
    ListenAddress 192.168.68.80
    HostKey /etc/ssh/ssh_host_rsa_key
    HostKey /etc/ssh/ssh_host_ecdsa_key
    HostKey /etc/ssh/ssh_host_ed25519_key
    SyslogFacility AUTHPRIV
    AuthenticationMethods "publickey,password"
    PermitRootLogin yes
    AuthorizedKeysFile      .ssh/authorized_keys
    PasswordAuthentication yes
    ChallengeResponseAuthentication no
    GSSAPIAuthentication no
    GSSAPICleanupCredentials no
    UsePAM yes
    X11Forwarding no
    PrintMotd no

Источники:

* https://wiki.centos.org/HowTos/Network/SecuringSSH
* https://man.openbsd.org/sshd_config.5
</t>
<t tx="avidclam.20200117162449.1">На машине ``kdc``::
    
    dnf install krb5-server
    vi /var/kerberos/krb5kdc/kdc.conf  # change realm
    vi /var/kerberos/krb5kdc/kadm5.acl  # change realm
    vi /etc/krb5.conf  # set up realm and kdc fqdn
    kdb5_util create -s -r MYNET  # master password here!
    
Note:
    
    Для замены в vi можно использовать команды::

    :%s/EXAMPLE\.COM/MYNET/g
    :%s/example\.com/mynet/g

Запускаемся::
    systemctl enable krb5kdc
    systemctl enable kadmin
    systemctl start krb5kdc
    systemctl start kadmin
    firewall-cmd --add-service=kerberos --permanent
    firewall-cmd --add-service=kadmin --permanent
    firewall-cmd --add-service=kpasswd --permanent
    firewall-cmd --reload

Создаем принципалов с помощью утилиты ``kadmin.local``. Далее команды внутри утилиты::
    
    addprinc root/admin
    addprinc myuser
    addprinc -randkey host/kdc.mynet
    ktadd host/kdc.mynet
    quit

Источники:

* https://codingbee.net/rhce/rhce-kerberos
* https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/configuring_a_kerberos_5_server
</t>
<t tx="avidclam.20200117170942.1">На машине ``server``, куда мы должны будем заходить через ssh с авторизацией в Kerberos,
нужно создать пользователя, например, ``myuser`` и запретить соединения под root::
    
    useradd myuser
    passwd -l myuser  # krb5 password only
    dnf install krb5-workstation

Нужно скопировать файл /etc/krb5.conf на server и настроить sshd.
Файл /etc/ssh/sshd_config будет выглядеть примерно так::
    
    HostKey /etc/ssh/ssh_host_rsa_key
    HostKey /etc/ssh/ssh_host_ecdsa_key
    HostKey /etc/ssh/ssh_host_ed25519_key
    SyslogFacility AUTHPRIV
    PermitRootLogin no
    AuthorizedKeysFile      .ssh/authorized_keys
    PasswordAuthentication yes
    ChallengeResponseAuthentication no
    KerberosAuthentication yes
    KerberosOrLocalPasswd yes
    GSSAPIAuthentication no
    GSSAPICleanupCredentials no
    UsePAM yes
    X11Forwarding no

Перезапустим sshd::
    
    systemctl restart sshd
    
Теперь при входе по ssh пароли будут проверяться в kerberos. Конфигурировать рабочую станцию ws не потребовалось.

Кстати, после входа на server можно проверить работу сервиса смены пароля kerberos::
    
    kpasswd

</t>
<t tx="avidclam.20200118194844.1">Для того, чтобы не просто проверять пароль через Kerberos, а иметь возможность, 
однажды авторизовавшись, входить без пароля, пока действует ticket, нужны другие настройки.

Сначала нужно внести ``server`` в KDC, запустив ``kadmin`` на машине server и задав следующие команды::
    
    addprinc -randkey host/server.mynet
    ktadd host/server.mynet

Затем установить SSSD::
    
    dns install sssd

и настроить, создав файл /etc/sssd/sssd.conf::
    
    [sssd]
        services = nss, pam
        domains = MYNET
    
    [domain/MYNET]
        id_provider = files
        auth_provider = krb5
        krb5_realm = MYNET
        krb5_server = kdc.mynet
        krb5_validate = true

Файл /etc/ssh/sshd_config нужно поменять таким образом, чтобы работала не встроенная авторизация Kerberos, а внешняя::
    
    HostKey /etc/ssh/ssh_host_rsa_key
    HostKey /etc/ssh/ssh_host_ecdsa_key
    HostKey /etc/ssh/ssh_host_ed25519_key
    SyslogFacility AUTHPRIV
    PermitRootLogin no
    AuthorizedKeysFile      .ssh/authorized_keys
    PasswordAuthentication yes
    ChallengeResponseAuthentication no
    #KerberosAuthentication yes
    #KerberosOrLocalPasswd yes
    GSSAPIAuthentication yes
    GSSAPICleanupCredentials yes
    UsePAM yes
    X11Forwarding no

Далее::
    
    chmod 600 /etc/sssd/sssd.conf
    systemctl start sssd
    systemctl restart sshd

На рабочей станции ``ws`` необходимо также установить ``krb5-workstation``, скопировать содержимое /etc/krb5.conf и аналогично внести рабочую станцию в KDC с помощью kadmin.
Теперь вход по ssh нужно проводить в два этапа::
    
    kinit
    ssh server

</t>
</tnodes>
</leo_file>
